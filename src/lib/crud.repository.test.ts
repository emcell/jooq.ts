import dotenv from 'dotenv';
import {
  ALONE,
  Alone,
  LOCATION,
  Location,
  setupDb,
  testLocations,
  testSchema,
} from '../test/test-utils';
import { CrudRepository } from './crud.repository';
import { DSL } from './dsl/dsl';
import { DSLContext } from './dsl/dsl.context';

dotenv.config();

describe('withDatabase', () => {
  setupDb(beforeEach, testSchema);
  let create: DSLContext;
  let locationRepository: CrudRepository<Location, 'id'>;
  beforeEach(async () => {
    create = DSL.context({
      type: 'postgres',
      config: {
        connectionString: process.env.DATABASE_URL,
      },
    });
    locationRepository = new CrudRepository(create, LOCATION, 'id');
  });
  afterEach(async () => {
    await create.end();
  });
  it('crud', async () => {
    const locations = await locationRepository.insertAll(testLocations);
    locations.sort((a, b) => a.id - b.id);
    expect(locations).toStrictEqual(testLocations);
    const loadedLoactions = await locationRepository.findAll();
    loadedLoactions.sort((a, b) => a.id - b.id);
    expect(loadedLoactions).toStrictEqual(testLocations);
    let l = await locationRepository.findOneByIdOrThrow(testLocations[0].id);
    expect(l).toStrictEqual(testLocations[0]);
    l = await locationRepository.findOneById(testLocations[0].id);
    expect(l).toStrictEqual(testLocations[0]);
    await expect(locationRepository.findOneByIdOrThrow(1234)).rejects.toThrow();
    expect(await locationRepository.findOneById(12345)).toBeUndefined;
    const found = await locationRepository.find(
      LOCATION.name.eq(testLocations[1].name),
    );
    expect(found.length).toBe(1);
    expect(found[0]).toStrictEqual(testLocations[1]);
    l = await locationRepository.findFirst(
      LOCATION.name.eq(testLocations[1].name),
    );
    expect(l).toStrictEqual(testLocations[1]);
    expect(
      await locationRepository
        .selectId()
        .where(LOCATION.name.eq(testLocations[2].name))
        .fetchOneOrThrow(),
    ).toBe(testLocations[2].id);
    await locationRepository.deleteById(testLocations[0].id);
    expect((await locationRepository.findAll()).length).toBe(
      testLocations.length - 1,
    );
    await locationRepository.delete(LOCATION.id.eq(testLocations[1].id));
    expect((await locationRepository.findAll()).length).toBe(
      testLocations.length - 2,
    );
  });
  it('insertAutoGenerated single', async () => {
    const testData: Alone[] = [
      { id: 100, name: 'a', bool: true, date: new Date() },
      {
        id: 101,
        name: 'b',
        bool: false,
        date: new Date(),
        roflKopter: 'asdf',
      } as Alone,
      { id: 102, name: 'c', date: new Date() },
    ];
    const aloneRepository = new CrudRepository(create, ALONE, 'id');
    let test = await aloneRepository.insertAutoGenerated(testData[0]);
    expect(test).toBeTruthy();
    expect(test.id).toBe(1);
    test = await aloneRepository.insertAutoGenerated(testData[1]);
    expect(test).toBeTruthy();
    expect(test.id).toBe(2);
  });
  it('insertAutoGenerated all', async () => {
    const testData: Alone[] = [
      { id: 100, name: 'a', bool: true, date: new Date() },
      {
        id: 101,
        name: 'b',
        bool: false,
        date: new Date(),
        roflKopter: 'asdf',
      } as Alone,
      { id: 102, name: 'c', date: new Date() },
    ];
    const aloneRepository = new CrudRepository(create, ALONE, 'id');
    const list = await aloneRepository.insertAllAutoGenerated(testData);
    expect(list.length).toBe(testData.length);
    for (const alone of list) {
      expect(alone.id).not.toBeUndefined();
      expect(alone.id).toBeLessThan(100);
    }
  });
});
