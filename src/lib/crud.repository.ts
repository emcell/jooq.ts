import { Except } from 'type-fest';
import { Condition } from './condition';
import { DSL } from './dsl/dsl';
import { DSLContext } from './dsl/dsl.context';
import { Fetchable } from './dsl/fetchable';
import { Field } from './dsl/field';
import { OrderField } from './dsl/order';
import { TableWithFields } from './table';
import { FieldsForType, Subset } from './types';

export class CrudRepository<T, PK extends keyof T> {
  private readonly tableWithoutPK: TableWithFields<Except<T, PK>>;
  constructor(
    public readonly create: DSLContext,
    public readonly tableDefinition: TableWithFields<T>,
    public readonly primaryKey: PK,
  ) {
    this.tableWithoutPK = DSL.withoutFields(tableDefinition, primaryKey);
  }

  get primaryKeyField(): Field<T[PK]> {
    return this.tableDefinition.fields[this.primaryKey];
  }
  public async findAll(): Promise<T[]> {
    return this.create.selectFrom<T>(this.tableDefinition).fetch();
  }

  private removeUnmatchingFieldsAndCopyIfNecessary<ObjectType>(
    object: ObjectType,
    fields: FieldsForType<ObjectType>,
  ): ObjectType {
    if (Object.keys(object).find((key) => !fields[key as keyof ObjectType])) {
      const clonedObj: any = {};
      for (const key in fields) {
        clonedObj[key] = (object as any)[key];
      }
      return clonedObj as ObjectType;
    }
    return object;
  }

  public async insertAutoGenerated(object: Except<T, PK>): Promise<T> {
    object = this.removeUnmatchingFieldsAndCopyIfNecessary<Except<T, PK>>(
      object,
      this.tableWithoutPK.fields,
    );
    const o = this.create
      .insertInto(this.tableWithoutPK, [object])
      .returning(this.tableDefinition.fields)
      .fetchOneOrThrow();
    return (o as unknown) as T;
  }

  public async insertAllAutoGenerated(objects: Except<T, PK>[]): Promise<T[]> {
    const convertedObjects: Except<T, PK>[] = objects.map((object) =>
      this.removeUnmatchingFieldsAndCopyIfNecessary<Except<T, PK>>(
        object,
        this.tableWithoutPK.fields,
      ),
    );
    return (this.create
      .insertInto(this.tableWithoutPK, convertedObjects)
      .returning(this.tableDefinition.fields)
      .fetch() as unknown) as T[];
  }

  public async insert(object: T): Promise<T> {
    return this.create
      .insertInto(this.tableDefinition, [object])
      .returning()
      .fetchOneOrThrow();
  }
  public async insertAll(objects: T[]): Promise<T[]> {
    return this.create
      .insertInto(this.tableDefinition, objects)
      .returning()
      .fetch();
  }

  public async insertOnConflictUpdate(object: T): Promise<T> {
    return this.create
      .insertInto(this.tableDefinition, [object])
      .onConflict(this.primaryKey)
      .doUpdate()
      .setExcluded()
      .returning()
      .fetchOneOrThrow();
  }
  public async insertAllOnConflictUpdate(objects: T[]): Promise<T[]> {
    return this.create
      .insertInto(this.tableDefinition, objects)
      .onConflict(this.primaryKey)
      .doUpdate()
      .setExcluded()
      .returning()
      .fetch();
  }
  public async insertOnConflictDoNothing(object: T): Promise<T> {
    return this.create
      .insertInto(this.tableDefinition, [object])
      .onConflict(this.primaryKey)
      .doNothing()
      .returning()
      .fetchOneOrThrow();
  }
  public async insertAllOnConflictDoNothing(objects: T[]): Promise<T[]> {
    return this.create
      .insertInto(this.tableDefinition, objects)
      .onConflict(this.primaryKey)
      .doNothing()
      .returning()
      .fetch();
  }

  getWhereClauseForId(id: T[PK]): Condition {
    return this.tableDefinition.fields[this.primaryKey].eq(id as any);
  }

  public async update<K extends keyof T>(
    id: T[PK],
    object: Subset<T, K>,
  ): Promise<T> {
    return (await this.create
      .update(this.tableDefinition, object)
      .where(this.getWhereClauseForId(id))
      .returning(this.tableDefinition.fields)
      .fetchOneOrThrow()) as T;
  }

  public async findOneById(id: T[PK]): Promise<T | undefined> {
    return this.create
      .selectFrom(this.tableDefinition)
      .where(this.getWhereClauseForId(id))
      .fetchOne();
  }

  public async findOneByIdOrThrow(id: T[PK]): Promise<T | undefined> {
    return this.create
      .selectFrom(this.tableDefinition.table)
      .where(this.getWhereClauseForId(id))
      .fetchOneOrThrow();
  }
  public async find(
    conditions: Condition[] | Condition,
    orderBy?: OrderField<any>[],
  ): Promise<T[]> {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return this.create
      .selectFrom(this.tableDefinition)
      .where(conditions)
      .orderBy(orderBy || [])
      .fetch();
  }

  public async findFirst(
    conditions: Condition[] | Condition,
    orderBy?: OrderField<any>[],
  ): Promise<T> {
    return (await this.find(conditions, orderBy))[0];
  }

  public async findByIdsIn(ids: Array<T[PK]> | Fetchable<T[PK]>): Promise<T[]> {
    const where = this.primaryKeyField.in(ids);
    return this.create.selectFrom(this.tableDefinition).where(where).fetch();
  }
  public selectByIdsIn(ids: Array<T[PK]> | Fetchable<T[PK]>): Fetchable<T> {
    const where = this.primaryKeyField.in(ids);
    return this.create.selectFrom(this.tableDefinition).where(where);
  }

  public select() {
    return this.create.selectFrom(this.tableDefinition);
  }

  public selectId() {
    return this.create
      .select(this.tableDefinition.fields[this.primaryKey])
      .from(this.tableDefinition.table);
  }

  public async deleteById(id: T[PK]): Promise<number> {
    return await this.create
      .delete(this.tableDefinition.table)
      .where(this.getWhereClauseForId(id))
      .execute();
  }
  public async delete(conditions: Condition | Condition[]): Promise<number> {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return await this.create
      .delete(this.tableDefinition.table)
      .where(conditions)
      .execute();
  }
}
