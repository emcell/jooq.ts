import {
  DSLContext,
  Fetchable,
  FieldsForType,
  TableWithFields,
} from './dsl/dsl';
import { Except } from 'type-fest';
import { Condition } from './condition';
import { Field } from './field/field';

export class CrudRepository<T, PK extends keyof T> {
  private readonly fieldsWithoutPrimaryKey: Except<FieldsForType<T>, PK>;
  constructor(
    public readonly create: DSLContext,
    public readonly tableDefinition: TableWithFields<T>,
    public readonly primaryKey: PK,
  ) {
    this.fieldsWithoutPrimaryKey = this.cloneAndRemoveProperty(
      tableDefinition.fields,
      primaryKey,
    );
  }

  cloneAndRemoveProperty<T, KeyToDelete extends keyof T>(
    object: T,
    keyToDelete: KeyToDelete,
  ): Except<T, KeyToDelete> {
    const copy: Except<T, KeyToDelete> = { ...object };
    delete (copy as T)[keyToDelete];
    return copy;
  }

  get primaryKeyField(): Field<T[PK]> {
    return this.tableDefinition.fields[this.primaryKey];
  }
  public findAll(): Promise<T[]> {
    return this.create.selectFrom<T>(this.tableDefinition.table).fetch();
  }

  private removeUnmatchingFieldsAndCopyIfNecessary<ObjectType>(
    object: ObjectType,
    fields: FieldsForType<ObjectType>,
  ): ObjectType {
    if (Object.keys(object).find((key) => !fields[key as keyof ObjectType])) {
      const clonedObj: any = {};
      for (const key in Object.keys(fields)) {
        clonedObj[key] = (object as any)[key];
      }
      return clonedObj as ObjectType;
    }
    return object;
  }

  public insertAutoGenerated(object: Except<T, PK>): Promise<T>;
  public insertAutoGenerated(objects: Except<T, PK>[]): Promise<T>;
  public insertAutoGenerated(
    objects: Except<T, PK>[] | Except<T, PK>,
  ): Promise<T> {
    if (Array.isArray(objects)) {
      objects = objects.map((object) =>
        this.removeUnmatchingFieldsAndCopyIfNecessary(
          object,
          this.fieldsWithoutPrimaryKey,
        ),
      );
    } else {
      objects = this.removeUnmatchingFieldsAndCopyIfNecessary(
        objects,
        this.fieldsWithoutPrimaryKey,
      );
    }
    return this.create
      .insertInto(this.tableDefinition.table, objects)
      .returning<T>()
      .fetchOneOrThrow();
  }

  public insert(object: T): Promise<T>;
  public insert(objects: T[]): Promise<T>;
  public insert(objects: T[] | T): Promise<T> {
    return this.create
      .insertInto(this.tableDefinition.table, objects)
      .returning<T>()
      .fetchOneOrThrow();
  }

  getWhereClauseForId(id: T[PK]): Partial<T> {
    const whereClause: Partial<T> = {};
    whereClause[this.primaryKey] = id;
    return whereClause;
  }

  public update(id: T[PK], object: Partial<T>): Promise<T> {
    return this.create
      .update<T>(this.tableDefinition.table, object)
      .where(this.getWhereClauseForId(id))
      .returning<T>()
      .fetchOneOrThrow();
  }

  public findOneById(id: T[PK]): Promise<T | undefined> {
    return this.create
      .selectFrom(this.tableDefinition.table)
      .where(this.getWhereClauseForId(id))
      .fetchOne();
  }

  public findOneByIdOrThrow(id: T[PK]): Promise<T | undefined> {
    return this.create
      .selectFrom(this.tableDefinition.table)
      .where(this.getWhereClauseForId(id))
      .fetchOneOrThrow();
  }
  public find(condition: Condition): Promise<T[]>;
  public find(...conditions: Condition[]): Promise<T[]>;
  public find(conditions: Condition[] | Condition): Promise<T[]> {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return this.create
      .selectFrom(this.tableDefinition.table)
      .where(conditions)
      .fetchOneOrThrow();
  }
  public findByIdsIn(ids: Array<T[PK]> | Fetchable<T[PK]>): Promise<T[]> {
    const where = this.primaryKeyField.in(ids);
    return this.create
      .selectFrom(this.tableDefinition.table)
      .where(where)
      .fetch();
  }
  public selectByIdsIn(ids: Array<T[PK]> | Fetchable<T[PK]>): Fetchable<T> {
    const where = this.primaryKeyField.in(ids);
    return this.create.selectFrom(this.tableDefinition.table).where(where);
  }

  public select() {
    return this.create.selectFrom(this.tableDefinition.table);
  }

  public selectId() {
    return this.create
      .select(this.tableDefinition.fields[this.primaryKey])
      .from(this.tableDefinition.table);
  }
}
